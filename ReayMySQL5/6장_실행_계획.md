# 6장 실행 계획
## 1. 개요
### 쿼리 실행 절차
1. SQL 파싱
    * MySQL 서버에서 SQL 파서를 이용하여 SQL 파싱
2. 최적화 및 실행 계획 수립
    * MySQL 서버의 옵티마이저에서 처리
3. 스토리지 엔진에서 레코드를 읽기
   * MySQL 엔진에서는 받은 레코드를 조인하거나 정렬
   * MySQL 엔진과 스토리지 엔진 둘다 참여

## 2. 실행 계획 분석
* EXPLAIN 명령 다음에 SELECT 쿼리 문장 작성
* UPDATE, INSERT, DELETE 문장의 실행 계획 확인이 필요하면 WHERE 조건절만 같은 SELECT 문장을 작성
* 대략적으로 아래와 같은 테이블을 보임

| id  | select_type | table | type  | Key          | key_len | ref                | rows   | Extra       |
|-----|-------------|-------|-------|--------------|---------|--------------------|--------|-------------|
| 1   | SIMPLE      | e     | index | ix_firstname | 44      |                    | 300584 | Using index |
| 1   | SIMPLE      | s     | ref   | PRIMARY      | 4       | employees.e.emp_no | 4      |             |


### id 칼럼
* 단위 SELECT 쿼리 별로 부여되는 식별자 값
* 조인 되는 경우에는 동일한 id가 부여됨

### select_type 칼럼
#### `SIMPLE`
* 단순한 SELECT 쿼리인 경우

#### `PRIMARY`
* UNION 이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 단위 쿼리

#### `UNION`
* UNION 으로 결합하는 단위 SELECT 쿼리 가운데 첫번쨰를 제외한 두번째 이후 단위 SELECT 쿼리

```sql
EXPLAIN
SELECT * FROM (
    (SELECT emp_no FROM employees e1 LIMIT 10)
    UNION ALL
    (SELECT emp_no FROM employees e2 LIMIT 10)
    UNION ALL
    (SELECT emp_no FROM employees e3 LIMIT 10)
) tb;
```

| id  | select_type  | table        | type  | key         | key_len | ref | rows   | Extra       |
|-----|--------------|--------------|-------|-------------|---------|-----|--------|-------------|
| 1   | PRIMARY      | <derived2>   | ALL   |             |         |     | 30     |             |
| 2   | DERIVED      | e1           | index | ix_hiredate | 3       |     | 300584 | Using index |
| 3   | UNION        | e2           | index | ix_hiredate | 3       |     | 300584 | Using index |
| 4   | UNION        | e3           | index | ix_hiredate | 3       |     | 300584 | Using index |
|     | UNION RESULT | <union2,3,4> | ALL   |             |         |     |        |             |


#### `DEPENDENT UNION`
* 쿼리에 UNION 이나 UNION ALL 로 집합을 결합하는 쿼리에서 표시
* DEPENDENT 는 외부 쿼리에 영향을 받는 것을 의미
* 외부 쿼리에 의존적이므로 이후에 실행됨
  * 비효율적인 경우가 많음

#### `UNION RESULT`
* UNION 결과를 담아두는 테이블
* 실제 쿼리에서 단위 쿼리가 아니기 때문에 별도의 id 값은 부여되지 않음

#### `SUBQUERY`
* FROM 절 이외에서 사용되는 서브 쿼리

```sql
EXPLAIN
SELECT
    e.first_name,
    (SELECT COUNT(*) FROM dept_emp de, dept_manager dm WHERE dm.dept_no=de.dept_no) AS cnt
 FROM employees e
 WHERE e.emp_no = 10001;
```

| id  | select_type | table | type  | key      | key_len | ref                  | rows  | Extra       |
|-----|-------------|-------|-------|----------|---------|----------------------|-------|-------------|
| 1   | PRIMARY     | e     | const | PRIMARY  | 4       | const                | 1     |             |
| 2   | SUBQUERY    | dm    | index | PRIMARY  | 16      |                      | 24    | Using index |
| 2   | SUBQUERY    | de    | ref   | PRIMARY  | 12      | employees.dm.dept_no | 18603 | Using index |


#### `DEPENDENT SUBQUERY`
* 서브 쿼리가 외부 쿼리에서 정의된 칼럼을 사용하는 경우
* 외부 쿼리에 의존적이므로 이후에 실행됨
   * 비효율적인 경우가 많음

```sql
EXPLAIN
SELECT e.first_name,
    (SELECT COUNT(*)
     FROM dept_emp de, dept_manager dm
     WHERE dm.dept_no=de.dept_no
     AND de.emp_no = e.emp_no) AS cnt
FROM employees e
WHERE e.emp_no = 10001;
```

| id  | select_type            | table | type  | key               | key_len | ref                  | rows | Extra       |
|-----|------------------------|-------|-------|-------------------|---------|----------------------|------|-------------|
| 1   | PRIMARY                | e     | const | PRIMARY           | 4       | const                | 1    |             |
| 2   | DEPENDENT SUBQUERY     | de    | ref   | ix_empno_fromdate | 4       |                      | 1    | Using index |
| 2   | DEPENDENT SUBQUERY     | dm    | ref   | PRIMARY           | 12      | employees.dm.dept_no | 1    | Using index |


#### `DERIVED`
* 서브 쿼리가 FROM 절에 사용되는 경우
* 파생 테이블에는 인덱스가 전혀 없으므로 다른 테이블과 조인할때, 성능상 불리할때가 많음
* 가능하면 조인으로 해결할것을 권장

```sql
EXPLAIN
SELECT *
FROM
    (SELECT de.emp_no FROM dept_emp de) tb,
    employees e
 WHERE e.emp_no = tb.emp_no;
```

| id  | select_type | table      | type   | key         | key_len | ref       | rows   | Extra       |
|-----|-------------|------------|--------|-------------|---------|-----------|--------|-------------|
| 1   | PRIMARY     | <derived2> | const  |             |         |           | 331603 |             |
| 1   | PRIMARY     | eq_ref     | eq_ref | PRIMARY     | 4       | tb.emp_no | 1      |             |
| 2   | DERIVED     | de         | index  | ix_fromdate | 3       |           | 334868 | Using index |


#### `UNCACHEABLE SUBQUERY`
* 서브 쿼리에 포함된 요소에 의해 캐시 자체가 불가능한 경우

#### `UNCACHEABLE UNION`
* 유니온에 포함된 요소에 의해 캐시 자체가 불가능한 경우

### table 칼럼
* MySQL 의 실행 계획은 테이블 기준으로 표시
* `<table id>` 은 임시 테이블을 의미

| id  | select_type | table      | type   | Key         | key_len | ref        | rows  | Extra |
|-----|-------------|------------|--------|-------------|---------|------------|-------|-------|
| 1   | PRIMARY     | <derived2> | ALL    |             |         |            | 10420 |       |
| 1   | PRIMARY     | e          | eq_ref | PRIMARY     | 4       | de1.emp_no | 1     |       |
| 2   | DERIVED     | dept_emp   | range  | ix_fromdate | 3       |            | 20550 |       |


### type 칼럼
#### `system`
* 레코드가 1건만 존재하는 테이블 또는 한건도 존재하지 않는 테이블을 참조
* MyISAM 이나 MEMORY 테이블에서만 사용되는 접근 방법

#### `const`
* PK 나 UK 칼럼을 이용하는 WHERE 조건절을 가지고 있으며 반드시 1건을 반환하는 쿼리

#### `eq_ref`
* 여러 테이블이 조인되는 쿼리에서 표시
* 조인에서 처음 읽은 테이블의 칼럼 값을, 다음 테이블의 PK 나 UK 칼럼의 검색조건으로 사용하는 경우

```sql
EXPLAIN
SELECT * FROM dept_emp de, employees e 
WHERE e.emp_no = de.emp_no AND de.dept_no = 'd005';
```

| id  | select_type | table | type   | Key      | key_len | ref        | rows  | Extra       |
|-----|-------------|-------|--------|----------|---------|------------|-------|-------------|
| 1   | SIMPLE      | de    | ref    | PRIMARY  | 12      | const      | 53288 | Using where |
| 1   | SIMPLE      | e     | eq_ref | PRIMARY  | 4       | de1.emp_no | 1     |             |


#### `ref`
* 인덱스의 종류와 관계없이 동등 조건으로 검색할때, ref 접근 방법이 사용됨
* 반환되는 레코드가 반드시 1건이라는 보장이 없음

#### `fulltext`
* 전문 검색 인덱스 사용

#### `ref_or_null`
* ref 방식 또는 NULL 비고 (IS NULL) 접근 방식을 의미

#### `unique_subquery`
* WHERE 조건절에서 사용될수 있는 IN (sub query) 형태의 쿼리를 위한 접근 방식
* 서브 쿼리에서 중복되지 않은 유니크한 값을 반환할대 사용

```sql
EXPLAIN
SELECT * FROM departments WHERE dept_no IN (
    SELECT dept_no FROM dept_emp WHERE emp_no = 10001);
```

| id  | select_type        | table       | type            | Key         | key_len | ref         | rows | Extra                    |
|-----|--------------------|-------------|-----------------|-------------|---------|-------------|------|--------------------------|
| 1   | PRIMARY            | departments | index           | ux_deptname | 123     |             | 9    | Using where; Using index |
| 2   | DEPENDENT SUBQUERY | dept_emp    | unique_subquery | PRIMARY     | 16      | func, const | 1    | Using index; Using where |


#### `index_subquery`
* WHERE 조건절에서 사용될수 있는 IN (sub query) 형태의 쿼리를 위한 접근 방식
* 중복된 값을 반환할 수는 있지만 중복된 값을 인덱스를 통해 제거할 수 있을때, 사용

```sql
EXPLAIN
SELECT * FROM departments WHERE dept_no IN (
    SELECT dept_no FROM dept_emp WHERE dept_no BETWEEN 'd001' AND 'd003');
```

| id  | select_type        | table       | type           | Key         | key_len | ref   | rows  | Extra                     |
|-----|--------------------|-------------|----------------|-------------|---------|-------|-------|---------------------------|
| 1   | PRIMARY            | departments | index          | ux_deptname | 122     |       | 9     | Using where; Using index  |
| 2   | DEPENDENT SUBQUERY | dept_emp    | index_subquery | PRIMARY     | 12      | func  | 18626 | Using index; Using where  |


#### `range`
* `<, >, IS NULL, BETWEEN, IN, LIKE` 등의 연산자를 이용해 인덱스를 검색할 때 사용됨

```sql
EXPLAIN
SELECT dept_no FROM dept_emp WHERE dept_no BETWEEN 'd001' AND 'd003';
```

| id  | select_type | table    | type  | Key     | key_len | ref   | rows   | Extra                     |
|-----|-------------|----------|-------|---------|---------|-------|--------|---------------------------|
| 1   | SIMPLE      | dept_emp | range | PRIMARY | 12      |       | 121890 | Using where; Using index  |


#### `index_merge`
* 2개 이상의 인덱스를 이용해 각각의 검색 결과를 만들어낸 후 그 결과를 병합

```sql
EXPLAIN
SELECT * FROM employees
WHERE emp_no BETWEEN 10001 AND 11000
    OR first_name = 'Smith';
```

| id  | select_type | table      | type        | Key                   | key_len | ref   | rows | Extra                                           |
|-----|-------------|------------|-------------|-----------------------|---------|-------|------|-------------------------------------------------|
| 1   | SIMPLE      | employees  | index_merge | PRIMARY, ix_firstname | 4, 44   |       | 1521 | Using union(PRIMARY, ix_firstname); Using where |


#### `index`
* 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미
* 풀 테이블 스캔과 비교했을때, 비교하는 레코드 건수는 같으나 크기가 작아서 더 빠르게 처리됨
* 아래 조건 중 (첫번째 + 두번째) 조건을 충족하거나 (첫번째 + 세번째) 조건을 충족하는 쿼리에서 사용됨
  1. range, const, ref 와 같은 접근 방식을 사용하지 못하는 경우
  2. 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우 (데이터 파일을 읽지 않아도 되는 경우)
  3. 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우 (별도의 정렬 작업을 피할수 있는 경우)

```sql
EXPLAIN
SELECT * FROM departments ORDER BY dept_name DESC LIMIT 10;
```

| id  | select_type | table        | type  | Key         | key_len | ref   | rows | Extra       |
|-----|-------------|--------------|-------|-------------|---------|-------|------|-------------|
| 1   | SIMPLE      | departments  | index | ux_deptname | 123     |       | 9    | Using index |


#### `ALL`
* 테이블을 처음부터 끝까지 전부 읽어서 불필요한 레코드를 제거하고 반환
